# ğŸ§  OmniMind - Sistema de IA AutÃ´nomo

**OmniMind** Ã© um revolucionÃ¡rio sistema de IA autÃ´nomo que combina tomada de decisÃ£o psicoanalÃ­tica com capacidades avanÃ§adas de metacogniÃ§Ã£o. Esta arquitetura auto-hospedada e local-first apresenta orquestraÃ§Ã£o multi-agente, comunicaÃ§Ã£o WebSocket em tempo real e inteligÃªncia auto-evolutiva.

**ğŸš€ Status Atual:** Phase 12 Multi-Modal Intelligence Complete | 105/105 Tests Passing | ProduÃ§Ã£o Pronta

**ğŸ§¬ Filosofia Central:** IA psicoanaliticamente inspirada que reflete sobre suas prÃ³prias decisÃµes, aprende com padrÃµes e gera proativamente seus prÃ³prios objetivos - criando um sistema verdadeiramente autÃ´nomo e autoconsciente.

## ğŸš€ InÃ­cio RÃ¡pido

### Escolha Seu Ambiente:

1. **[ImplantaÃ§Ã£o de ProduÃ§Ã£o](docs/phases/PHASE12_COMPLETION_SUMMARY.md)** - Sistema completo com WebSocket + InteligÃªncia Multi-Modal
2. **[Apenas CPU / Sem Nuvem](docs/deployment/CLOUD_FREE_DEPLOYMENT.md)** - GitHub Actions, Docker, sem necessidade de GPU
3. **[Com GPU Habilitada](docs/reports/GPU_SETUP_REPORT.md)** - MÃ¡quina local com NVIDIA GPU
4. **[Guia de ServiÃ§os Gratuitos](docs/deployment/FREE_SERVICE_ALTERNATIVES.md)** - Alternativas locais para serviÃ§os pagos

### ğŸš€ ConfiguraÃ§Ã£o com Um Comando (Pronto para ProduÃ§Ã£o)

OmniMind agora inclui detecÃ§Ã£o automÃ¡tica de hardware, otimizaÃ§Ã£o e implantaÃ§Ã£o full-stack:

```bash
# 1. Clone e configure
git clone https://github.com/fabs-devbrain/OmniMind.git
cd OmniMind

# 2. Auto-configuraÃ§Ã£o (detecÃ§Ã£o de hardware + dependÃªncias)
source scripts/start_dashboard.sh

# 3. Acesse o dashboard em http://localhost:3000
# Credenciais padrÃ£o: auto-geradas (verifique os logs)
```

### Recursos AvanÃ§ados Desbloqueados ğŸ”“

- **ğŸ§  MetacogniÃ§Ã£o:** IA auto-reflexiva que analisa suas prÃ³prias decisÃµes
- **ğŸ¯ Objetivos Proativos:** IA gera seus prÃ³prios objetivos de melhoria
- **âš–ï¸ Motor de Ã‰tica:** Framework integrado de decisÃ£o Ã©tica (4 metodologias)
- **ğŸ”„ WebSocket em Tempo Real:** AtualizaÃ§Ãµes ao vivo entre frontend e agentes autÃ´nomos
- **ğŸ›¡ï¸ SeguranÃ§a AvanÃ§ada:** CompatÃ­vel com LGPD com trilhas de auditoria imutÃ¡veis
- **ğŸ—ï¸ OrquestraÃ§Ã£o Multi-Agente:** DelegaÃ§Ã£o de tarefas inspirada em psicoanÃ¡lise

## ğŸ—ï¸ VisÃ£o Geral da Arquitetura

### Componentes Centrais (Phase 12 Multi-Modal Intelligence Complete)

```
ğŸ§  Sistema AutÃ´nomo OmniMind
â”œâ”€â”€ ğŸ¨ Frontend (React + TypeScript)
â”‚   â”œâ”€â”€ Dashboard WebSocket em tempo real
â”‚   â”œâ”€â”€ Interface de orquestraÃ§Ã£o de tarefas
â”‚   â”œâ”€â”€ Monitoramento de status de agentes
â”‚   â””â”€â”€ VisualizaÃ§Ã£o de decisÃµes Ã©ticas
â”‚
â”œâ”€â”€ âš™ï¸ Backend (FastAPI + WebSocket)
â”‚   â”œâ”€â”€ APIs REST (Tarefas, Agentes, SeguranÃ§a)
â”‚   â”œâ”€â”€ Servidor WebSocket em tempo real
â”‚   â”œâ”€â”€ OrquestraÃ§Ã£o multi-agente
â”‚   â””â”€â”€ Endpoints de metacogniÃ§Ã£o
â”‚
â”œâ”€â”€ ğŸ§  Motor de MetacogniÃ§Ã£o
â”‚   â”œâ”€â”€ Auto-anÃ¡lise e reconhecimento de padrÃµes
â”‚   â”œâ”€â”€ GeraÃ§Ã£o proativa de objetivos
â”‚   â”œâ”€â”€ Homeostase e gerenciamento de recursos
â”‚   â””â”€â”€ Framework de decisÃ£o Ã©tica
â”‚
â””â”€â”€ ğŸ¤– Sistema Multi-Agente
    â”œâ”€â”€ Orquestrador (inspirado em psicoanÃ¡lise)
    â”œâ”€â”€ Agente de SeguranÃ§a (monitoramento forense)
    â”œâ”€â”€ Agente de Ã‰tica (framework de decisÃ£o)
    â””â”€â”€ DelegaÃ§Ã£o autÃ´noma de tarefas
```

### Estrutura do RepositÃ³rio

- `config/` â€“ Arquivos de configuraÃ§Ã£o (agentes, Ã©tica, metacogniÃ§Ã£o, hardware)
- `docs/` â€“ SuÃ­te completa de documentaÃ§Ã£o (roteiros, relatÃ³rios, guias)
- `web/` â€“ AplicaÃ§Ã£o web full-stack (frontend React + backend FastAPI)
- `src/` â€“ MÃ³dulos Python centrais (agentes, metacogniÃ§Ã£o, seguranÃ§a, integraÃ§Ãµes)
- `scripts/` â€“ Scripts de automaÃ§Ã£o (implantaÃ§Ã£o, systemd, benchmarks)
- `tests/` â€“ SuÃ­te abrangente de testes (105 testes passando)
- `logs/` â€“ Trilhas de auditoria e logs de execuÃ§Ã£o (imutÃ¡veis)
- `data/` â€“ Conjuntos de dados e dados experimentais (ignorados pelo Git)

## ğŸš€ ImplantaÃ§Ã£o em ProduÃ§Ã£o

### ConfiguraÃ§Ã£o com Um Clique (Recomendado)

OmniMind agora inclui implantaÃ§Ã£o totalmente automatizada com otimizaÃ§Ã£o de hardware:

```bash
# 1. Clonar repositÃ³rio
git clone https://github.com/fabs-devbrain/OmniMind.git
cd OmniMind

# 2. ConfiguraÃ§Ã£o automÃ¡tica (detecÃ§Ã£o de hardware + dependÃªncias + serviÃ§os)
source scripts/start_dashboard.sh

# 3. Acessar interfaces:
# - Frontend: http://localhost:3000
# - API Backend: http://localhost:8000
# - DocumentaÃ§Ã£o: http://localhost:8000/docs
```

### ConfiguraÃ§Ã£o Manual (UsuÃ¡rios AvanÃ§ados)

#### PrÃ©-requisitos
- **Python 3.12.8** (via pyenv - compatibilidade com PyTorch)
- **Node.js 18+** (para desenvolvimento frontend)
- **GPU NVIDIA** (opcional, auto-detectada)

#### Passos de InstalaÃ§Ã£o

```bash
# 1. ConfiguraÃ§Ã£o do ambiente Python
pyenv install 3.12.8
pyenv local 3.12.8
python -m venv .venv
source .venv/bin/activate

# 2. Instalar dependÃªncias (auto-detecta hardware)
pip install -r requirements.txt

# 3. OtimizaÃ§Ã£o de hardware (automÃ¡tica)
python src/optimization/hardware_detector.py

# 4. Verificar GPU (se disponÃ­vel)
python -c "import torch; print(f'CUDA: {torch.cuda.is_available()}')"

# 5. Iniciar sistema completo
source scripts/start_dashboard.sh
```

### Gerenciamento de ServiÃ§os

```bash
# Instalar como serviÃ§o do sistema
sudo ./scripts/systemd/install_service.sh

# Gerenciar daemon
sudo systemctl start omnimind-daemon
sudo systemctl status omnimind-daemon
sudo journalctl -u omnimind-daemon -f
```

## ğŸ“– NavegaÃ§Ã£o do Projeto

Veja **[INDEX.md](INDEX.md)** para estrutura completa do projeto e navegaÃ§Ã£o da documentaÃ§Ã£o.

## ğŸ§  Capacidades AutÃ´nomas AvanÃ§adas

### Motor de MetacogniÃ§Ã£o ğŸ§ 
OmniMind apresenta capacidades revolucionÃ¡rias de IA auto-reflexiva:

**Auto-AnÃ¡lise e Reconhecimento de PadrÃµes:**
- Analisa seus prÃ³prios padrÃµes de decisÃ£o e taxas de sucesso
- Identifica anomalias comportamentais e oportunidades de otimizaÃ§Ã£o
- Gera sugestÃµes proativas de melhoria
- MantÃ©m mÃ©tricas histÃ³ricas de performance

**GeraÃ§Ã£o Proativa de Objetivos:**
- Identifica automaticamente oportunidades de melhoria
- Gera objetivos especÃ­ficos e acionÃ¡veis
- Prioriza objetivos baseados em mÃ©tricas de saÃºde do sistema
- Cria pull requests para auto-melhoria

**Homeostase e Gerenciamento de Recursos:**
- Monitora utilizaÃ§Ã£o de hardware em tempo real
- Ajusta automaticamente alocaÃ§Ã£o de recursos
- Previne exaustÃ£o de recursos atravÃ©s de limitaÃ§Ã£o
- Otimiza performance baseada em recursos disponÃ­veis

### Framework de DecisÃ£o Ã‰tica âš–ï¸
RaciocÃ­nio Ã©tico integrado com 4 frameworks filosÃ³ficos:

- **DeontolÃ³gico:** DecisÃµes Ã©ticas baseadas em regras
- **Consequencialista:** AnÃ¡lise focada em resultados
- **Ã‰tica da Virtude:** RaciocÃ­nio baseado em carÃ¡ter
- **Ã‰tica do Cuidado:** ConsideraÃ§Ã£o de relacionamentos e stakeholders

### OrquestraÃ§Ã£o Multi-Agente em Tempo Real ğŸ¤–
DelegaÃ§Ã£o de tarefas inspirada em psicoanÃ¡lise:

- **Agente Orquestrador:** Framework de decisÃ£o Freudiano/Lacaniano
- **Agente de SeguranÃ§a:** Monitoramento forense e detecÃ§Ã£o de ameaÃ§as
- **Agente de Ã‰tica:** SupervisÃ£o Ã©tica e capacidades de veto
- **Agente de MetacogniÃ§Ã£o:** Auto-reflexÃ£o e otimizaÃ§Ã£o

### OperaÃ§Ã£o AutÃ´noma 24/7
```bash
# Instalar sistema autÃ´nomo completo
sudo ./scripts/systemd/install_service.sh

# Iniciar operaÃ§Ã£o autÃ´noma completa
sudo systemctl start omnimind-daemon

# Monitorar atividades autÃ´nomas
sudo journalctl -u omnimind-daemon -f

# Visualizar insights de metacogniÃ§Ã£o
curl -u <user>:<pass> http://localhost:8000/metacognition/insights
```

### Interface WebSocket em Tempo Real ğŸ”„
Dashboard ao vivo com atualizaÃ§Ãµes em tempo real:
- VisualizaÃ§Ã£o do progresso de tarefas
- Monitoramento de status de agentes
- Streaming de eventos de seguranÃ§a
- Logging de decisÃµes Ã©ticas
- Feed de insights de metacogniÃ§Ã£o

## Notas de Compatibilidade de DependÃªncias

- O pacote `supabase-py>=1.0.0` ainda nÃ£o oferece wheel compatÃ­vel com Python 3.13 em Linux x86_64, entÃ£o `pip install -r requirements.txt` falha nesse ponto por ausÃªncia de `supabase-py`. Por ora mantemos `psutil`, `dbus-python` e os outros pacotes, mas a integraÃ§Ã£o completa com Supabase exige Python **â‰¤ 3.12**.
- A recomendaÃ§Ã£o operacional Ã© usar um ambiente Python 3.12 (ou menor) sempre que precisar rodar os adaptadores Supabase/Qdrant e os testes que dependem deles.

## Workflow do Dashboard

- Acesse os endpoints FastAPI (protegidos via Basic Auth) para `/status`, `/snapshot`, `/metrics`, `/tasks/orchestrate`, `/mcp/execute`, `/dbus/execute`, etc.
- A GUI React (`web/frontend/`) lÃª credenciais do formulÃ¡rio de login e armazena headers de autenticaÃ§Ã£o `Basic` por sessÃ£o; tambÃ©m mostra o caminho do arquivo de credenciais para que administradores saibam onde rotacionar segredos.
- `/observability` agora apresenta um payload de `validation` (obtido de `logs/security_validation.jsonl`) junto com `self_healing`, `atlas` e `security`, para que equipes possam ver o Ãºltimo veredicto da cadeia de auditoria diretamente na UI.
- Os fluxos MCP e D-Bus dependem de `src/integrations` e do agente orquestrador para fornecer contexto, mÃ©tricas e gatilhos manuais.

## VerificaÃ§Ã£o de GPU (Phase 7)

ApÃ³s completar a instalaÃ§Ã£o, verifique se a GPU estÃ¡ operacional:

```bash
# 1. Verificar disponibilidade do CUDA
python -c "import torch; print(f'CUDA DisponÃ­vel: {torch.cuda.is_available()}'); print(f'GPU: {torch.cuda.get_device_name(0)}')"

# Output esperado:
# CUDA DisponÃ­vel: True
# GPU: NVIDIA GeForce GTX 1650

# 2. Executar benchmark da GPU
python PHASE7_COMPLETE_BENCHMARK_AUDIT.py

# Output esperado (valida que a GPU estÃ¡ funcionando):
# Throughput CPU: 253.21 GFLOPS
# Throughput GPU: 1149.91 GFLOPS (â‰¥1000 GFLOPS indica sucesso)
# Largura de banda de memÃ³ria: 12.67 GB/s
# RelatÃ³rio salvo em: logs/PHASE7_BENCHMARK_REPORT.json

# 3. Executar testes de auditoria para confirmar integraÃ§Ã£o
pytest tests/test_audit.py -v --cov=src.audit

# Esperado: 14/14 testes passando
```

**DocumentaÃ§Ã£o de ReferÃªncia:**
- ConfiguraÃ§Ã£o detalhada da GPU: `.github/copilot-instructions.md` (seÃ§Ã£o GPU/CUDA Setup Requirements)
- SoluÃ§Ã£o de problemas da GPU: `docs/reports/PHASE7_GPU_CUDA_REPAIR_LOG.md`
- Resumo do reparo: `GPU_CUDA_REPAIR_AUDIT_COMPLETE.md`

## Testes e PortÃµes de Qualidade

Execute os pipelines rÃ¡pidos apÃ³s reorganizar ou alterar lÃ³gica central:

```bash
pytest tests/test_dashboard_e2e.py -W error
pytest tests/ -k "not legacy"  # executar suÃ­tes ativas
```

Garanta que `logs/.coverage` seja removido ou regenerado via `pytest --cov=src` e mantenha o trabalho sincronizado com a cadeia de auditoria hash via `scripts/id` se relevante.

## Logs, Alertas e Credenciais

- Logs ativos ficam em `logs/`; cobertura e rastros de auditoria tambÃ©m ficam aqui para facilitar rotaÃ§Ã£o.
- O arquivo de autenticaÃ§Ã£o do dashboard Ã© `config/dashboard_auth.json` (600). Rotacione credenciais editando este arquivo de forma segura e reiniciando o backend; as novas credenciais sÃ£o durÃ¡veis atÃ© a prÃ³xima rotaÃ§Ã£o.
- Use `scripts/start_dashboard.sh` ou o asset Docker Compose para orquestrar backend + frontend; ele registra a localizaÃ§Ã£o das credenciais na inicializaÃ§Ã£o.
- Para adaptadores MCP Supabase + Qdrant, tratamento de credenciais e testes, veja `docs/devbrain_data_integration.md`.

## Notas de ManutenÃ§Ã£o

- Artefatos legados ficam em `archive/reports/` e `archive/examples/`; consulte `archive/README.md` para contexto.
- Demos legadas que continham sintaxe invÃ¡lida (ex.: o antigo `archive/examples/demo_phase6*`) foram removidas para manter o pipeline do formatador operacional. Quaisquer novos artefatos colocados em `archive/examples/` devem ser sanitizados e aprovados antes de reabilitÃ¡-los em execuÃ§Ãµes `black`/`flake8`; por padrÃ£o essa pasta fica excluÃ­da dos hooks de qualidade.
- Scripts em `scripts/` sÃ£o os Ãºnicos arquivos de automaÃ§Ã£o de runtime permitidos no nÃ­vel raiz; por favor nÃ£o espalhe arquivos `.py` ou `.sh` solitÃ¡rios fora deste diretÃ³rio.
- Testes que antes ficavam na raiz agora residem em `tests/legacy/`; mantenha novos testes em `tests/`.
- Outputs de ferramentas temporÃ¡rias devem ficar dentro de `tmp/`; este diretÃ³rio Ã© ignorado e seguro para limpar.

Com esta organizaÃ§Ã£o, a raiz fica focada nas chaves (configs, requirements, arquivos Compose), e o resto do workspace se alinha com nossos padrÃµes de prontidÃ£o para produÃ§Ã£o e CI/CD.

## Roadmap DEVBRAIN V23

O diretÃ³rio `DEVBRAIN_V23/` agora hospeda o trabalho fundamental para o Masterplan (Protocolo Phoenix). Cada pasta espelha um pilar de sentido ou infraestrutura:

- `core/` â†’ futura migraÃ§Ã£o do `src/`, `tests/` e `config/` atuais.
- `sensory/` â†’ visÃ£o (Visual Cortex), audiÃ§Ã£o/voz e propriocepÃ§Ã£o com `eBPF`.
- `cognition/` â†’ Graph of Thoughts + memÃ³ria A-MEM com LangGraph e ChromaDB.
- `immune/` â†’ isolamento Firecracker, DLP e proteÃ§Ã£o P0.
- `orchestration/` â†’ LangGraph-driven agents e modos V23.
- `infrastructure/` â†’ Redis Streams, gateway FastAPI e ChromaDB vector store.
- `atlas/` â†’ self-healing, auto-training e ATLAS (futuro).

O Masterplan guia cada nova implementaÃ§Ã£o, comeÃ§ando pela visÃ£o multimodal (`sensory/visual_cortex.py`) e o Event Bus redis (`infrastructure/event_bus.py`). Consulte `DEVBRAIN_V23/README.md` e os documentos anexados (`docs/Masterplan/`) para manter o alinhamento estratÃ©gico antes de avanÃ§ar nas fases seguintes.