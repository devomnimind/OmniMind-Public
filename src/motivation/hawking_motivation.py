"""
Hawking Radiation Motivation Engine - Knowledge Evaporation System

Implements intrinsic motivation through Hawking radiation analogy:
unused knowledge "evaporates" generating urgency to apply learning before loss.

Based on:
- Hawking radiation: T = ℏc³/(8πGMk_B)
- Information paradox and correlation preservation
- Bekenstein-Hawking temperature
- Black hole thermodynamics

This creates productive urgency and prevents knowledge hoarding.

Author: This work was conceived by Fabrício da Silva and implemented with AI assistance
from GitHub Copilot (Claude Haiku 4.5 and Grok Code Fast 1), with constant code review
and debugging across various models including Gemini and Perplexity AI, under
theoretical coordination by the author.
License: MIT
"""

from __future__ import annotations

import logging
import random
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)

# Physical constants (simplified for computational use)
HAWKING_CONSTANT = 1.0  # Normalized Hawking temperature constant
MIN_TEMPERATURE = 0.001  # Minimum temperature to avoid zero evaporation
MAX_TEMPERATURE = 10.0  # Maximum temperature cap


@dataclass
class KnowledgeItem:
    """
    Single piece of knowledge in the system.

    Attributes:
        content: Knowledge content (description/identifier)
        mass: Knowledge "mass" (complexity/importance)
        last_used: Timestamp of last usage
        use_count: Number of times used
        correlations: Related knowledge items
        creation_time: When knowledge was acquired
    """

    content: str
    mass: float
    last_used: datetime
    use_count: int = 0
    correlations: List[str] = field(default_factory=list)
    creation_time: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def __post_init__(self) -> None:
        """Initialize defaults."""


@dataclass
class EvaporationEvent:
    """
    Record of knowledge evaporation.

    Attributes:
        knowledge_id: ID of evaporated knowledge
        mass_lost: Amount of mass evaporated
        correlations_preserved: Correlations extracted before evaporation
        frustration_energy: Frustration generated by loss
        motivation_boost: Motivation to use remaining knowledge
        timestamp: When evaporation occurred
    """

    knowledge_id: str
    mass_lost: float
    correlations_preserved: List[str]
    frustration_energy: float
    motivation_boost: float
    timestamp: datetime


class HawkingMotivationEngine:
    """
    Knowledge evaporation system via Hawking radiation analogy.

    Knowledge that goes unused "evaporates" through Hawking radiation,
    creating urgency to apply learned concepts before loss.

    Key mechanisms:
    - Temperature-based evaporation (hotter = faster evaporation)
    - Correlation preservation (information paradox resolution)
    - Frustration generation (productive discomfort)
    - Motivation amplification (urgency before loss)
    """

    def __init__(
        self,
        base_temperature: float = 1.0,
        evaporation_threshold_days: float = 7.0,
        correlation_strength: float = 0.7,
    ) -> None:
        """
        Initialize Hawking motivation engine.

        Args:
            base_temperature: Base Hawking temperature
            evaporation_threshold_days: Days before unused knowledge evaporates
            correlation_strength: Strength of correlation preservation (0-1)
        """
        self.temperature = base_temperature
        self.evaporation_threshold = timedelta(days=evaporation_threshold_days)
        self.correlation_strength = correlation_strength

        # Knowledge storage
        self.knowledge_base: Dict[str, KnowledgeItem] = {}

        # Evaporation history
        self.evaporation_history: List[EvaporationEvent] = []

        # Compute evaporation rate from temperature
        self.evaporation_rate = self._calculate_rate()

        logger.info(
            f"HawkingMotivationEngine initialized: T={base_temperature:.2f}, "
            f"rate={self.evaporation_rate:.4f}"
        )

    def _calculate_rate(self) -> float:
        """
        Calculate evaporation rate from Hawking temperature.

        Hawking radiation rate increases with temperature.
        Smaller black holes (less mass) are hotter and evaporate faster.

        Returns:
            Evaporation rate (0-1 per time unit)
        """
        # Clamp temperature to valid range
        temp = max(MIN_TEMPERATURE, min(self.temperature, MAX_TEMPERATURE))

        # Rate proportional to temperature (hotter = faster evaporation)
        rate = HAWKING_CONSTANT * temp / MAX_TEMPERATURE

        return float(max(0.0, min(rate, 1.0)))

    def add_knowledge(self, knowledge_id: str, content: str, mass: float = 1.0) -> None:
        """
        Add new knowledge to the system.

        Args:
            knowledge_id: Unique identifier
            content: Knowledge content/description
            mass: Knowledge mass (importance/complexity)
        """
        item = KnowledgeItem(
            content=content,
            mass=mass,
            last_used=datetime.now(timezone.utc),
        )

        self.knowledge_base[knowledge_id] = item

        logger.debug(f"Knowledge added: {knowledge_id} (mass={mass:.2f})")

    def use_knowledge(self, knowledge_id: str) -> bool:
        """
        Mark knowledge as used (prevents evaporation).

        Args:
            knowledge_id: ID of knowledge being used

        Returns:
            True if knowledge exists and was marked used
        """
        if knowledge_id not in self.knowledge_base:
            logger.warning(f"Knowledge {knowledge_id} not found")
            return False

        item = self.knowledge_base[knowledge_id]
        item.last_used = datetime.now(timezone.utc)
        item.use_count += 1

        logger.debug(f"Knowledge used: {knowledge_id} (count={item.use_count})")

        return True

    def add_correlation(
        self, knowledge_id: str, related_id: str, bidirectional: bool = True
    ) -> None:
        """
        Add correlation between knowledge items.

        Args:
            knowledge_id: Source knowledge ID
            related_id: Related knowledge ID
            bidirectional: Add reverse correlation too
        """
        if knowledge_id in self.knowledge_base:
            item = self.knowledge_base[knowledge_id]
            if related_id not in item.correlations:
                item.correlations.append(related_id)

        if bidirectional and related_id in self.knowledge_base:
            related = self.knowledge_base[related_id]
            if knowledge_id not in related.correlations:
                related.correlations.append(knowledge_id)

        logger.debug(f"Correlation added: {knowledge_id} <-> {related_id}")

    def evaporate_unused_knowledge(
        self, current_time: Optional[datetime] = None
    ) -> Tuple[List[str], Dict[str, Any]]:
        """
        Evaporate unused memories, generating motivation signals.

        Args:
            current_time: Current time (default: now)

        Returns:
            Tuple of (evaporated_ids, motivation_data)
        """
        if current_time is None:
            current_time = datetime.now(timezone.utc)

        evaporated_ids: List[str] = []
        total_frustration = 0.0
        total_motivation = 0.0
        total_mass_lost = 0.0

        # Find unused knowledge
        for knowledge_id, item in list(self.knowledge_base.items()):
            time_unused = current_time - item.last_used

            # Check if should evaporate
            if time_unused > self.evaporation_threshold:
                # Probability of evaporation based on rate and mass
                # Smaller mass evaporates faster (like smaller black holes)
                evap_prob = self.evaporation_rate / max(item.mass, 0.1)
                evap_prob = min(evap_prob, 1.0)

                if random.random() < evap_prob:
                    # Extract correlations before evaporation
                    correlations = self._extract_correlations(item)

                    # Compute frustration (loss signal)
                    frustration = self._compute_frustration(item, time_unused)

                    # Generate motivation (urgency for related knowledge)
                    motivation = self._generate_urgency(correlations)

                    # Create evaporation event
                    event = EvaporationEvent(
                        knowledge_id=knowledge_id,
                        mass_lost=item.mass,
                        correlations_preserved=correlations,
                        frustration_energy=frustration,
                        motivation_boost=motivation,
                        timestamp=current_time,
                    )

                    self.evaporation_history.append(event)

                    # Update totals
                    total_frustration += frustration
                    total_motivation += motivation
                    total_mass_lost += item.mass

                    # Remove from knowledge base
                    del self.knowledge_base[knowledge_id]
                    evaporated_ids.append(knowledge_id)

                    logger.info(
                        f"Knowledge evaporated: {knowledge_id} "
                        f"(unused for {time_unused.days} days, "
                        f"frustration={frustration:.2f})"
                    )

        # Compute overall motivation signal
        motivation_data = {
            "evaporated_count": len(evaporated_ids),
            "total_mass_lost": total_mass_lost,
            "frustration": total_frustration,
            "motivation": total_motivation,
            "urgency_factor": self._compute_urgency_factor(evaporated_ids),
            "correlations_at_risk": self._identify_at_risk_correlations(),
        }

        return evaporated_ids, motivation_data

    def _extract_correlations(self, item: KnowledgeItem) -> List[str]:
        """
        Extract correlations from knowledge before evaporation.

        Information is preserved in correlations (information paradox).

        Args:
            item: Knowledge item being evaporated

        Returns:
            List of correlation identifiers
        """
        # Correlations are preserved with some strength
        preserved = []

        for corr_id in item.correlations:
            if random.random() < self.correlation_strength:
                preserved.append(corr_id)

        return preserved

    def _compute_frustration(self, item: KnowledgeItem, time_unused: timedelta) -> float:
        """
        Compute frustration from knowledge loss.

        Args:
            item: Knowledge being lost
            time_unused: Time since last use

        Returns:
            Frustration energy (0-1)
        """
        # Frustration proportional to:
        # 1. Mass (more important = more frustration)
        # 2. Recency (recently acquired but unused = more frustration)

        age_factor = (datetime.now(timezone.utc) - item.creation_time).days
        recency_frustration = 1.0 / max(age_factor, 1.0)

        mass_frustration = item.mass / 10.0  # Normalize

        # Lacanian lack: frustration from desire (never used)
        usage_frustration = 1.0 / max(item.use_count + 1, 1.0)

        total = (recency_frustration + mass_frustration + usage_frustration) / 3.0

        return float(max(0.0, min(total, 1.0)))

    def _generate_urgency(self, correlations: List[str]) -> float:
        """
        Generate motivation urgency for correlated knowledge.

        Args:
            correlations: Preserved correlations

        Returns:
            Motivation boost (0-1)
        """
        # More correlations = more urgency to use related knowledge
        urgency = len(correlations) / 10.0  # Normalize

        # Boost urgency if correlations point to unused knowledge
        for corr_id in correlations:
            if corr_id in self.knowledge_base:
                corr_item = self.knowledge_base[corr_id]
                time_unused = (datetime.now(timezone.utc) - corr_item.last_used).total_seconds()
                # Add urgency if correlation is also unused
                if time_unused > self.evaporation_threshold.total_seconds() * 0.5:
                    urgency += 0.1

        return float(max(0.0, min(urgency, 1.0)))

    def _compute_urgency_factor(self, evaporated_ids: List[str]) -> float:
        """
        Compute overall urgency factor from evaporation events.

        Args:
            evaporated_ids: IDs of evaporated knowledge

        Returns:
            Urgency factor (0-1)
        """
        if not evaporated_ids:
            return 0.0

        # Urgency increases with evaporation rate
        recent_evaporations = len(
            [
                e
                for e in self.evaporation_history[-100:]
                if (datetime.now(timezone.utc) - e.timestamp).days < 1
            ]
        )

        urgency = recent_evaporations / 10.0

        return float(max(0.0, min(urgency, 1.0)))

    def _identify_at_risk_correlations(self) -> List[str]:
        """
        Identify knowledge at risk of evaporation.

        Returns:
            List of at-risk knowledge IDs
        """
        at_risk = []
        current_time = datetime.now(timezone.utc)

        for knowledge_id, item in self.knowledge_base.items():
            time_unused = current_time - item.last_used

            # At risk if > 50% of threshold
            if time_unused > self.evaporation_threshold * 0.5:
                at_risk.append(knowledge_id)

        return at_risk

    def adjust_temperature(self, new_temperature: float) -> None:
        """
        Adjust Hawking temperature (evaporation rate).

        Args:
            new_temperature: New temperature value
        """
        self.temperature = max(MIN_TEMPERATURE, min(new_temperature, MAX_TEMPERATURE))
        self.evaporation_rate = self._calculate_rate()

        logger.info(
            f"Temperature adjusted: T={self.temperature:.2f}, " f"rate={self.evaporation_rate:.4f}"
        )

    def get_statistics(self) -> Dict[str, Any]:
        """
        Get engine statistics.

        Returns:
            Dict with statistics
        """
        at_risk = self._identify_at_risk_correlations()

        return {
            "total_knowledge": len(self.knowledge_base),
            "temperature": self.temperature,
            "evaporation_rate": self.evaporation_rate,
            "total_evaporated": len(self.evaporation_history),
            "at_risk_count": len(at_risk),
            "at_risk_ids": at_risk,
            "average_mass": (
                sum(item.mass for item in self.knowledge_base.values()) / len(self.knowledge_base)
                if self.knowledge_base
                else 0.0
            ),
            "average_use_count": (
                sum(item.use_count for item in self.knowledge_base.values())
                / len(self.knowledge_base)
                if self.knowledge_base
                else 0.0
            ),
        }

    def get_knowledge_status(self, knowledge_id: str) -> Optional[Dict[str, Any]]:
        """
        Get status of specific knowledge.

        Args:
            knowledge_id: Knowledge identifier

        Returns:
            Status dict or None if not found
        """
        if knowledge_id not in self.knowledge_base:
            return None

        item = self.knowledge_base[knowledge_id]
        current_time = datetime.now(timezone.utc)
        time_unused = current_time - item.last_used

        evaporation_risk = time_unused.total_seconds() / self.evaporation_threshold.total_seconds()
        evaporation_risk = min(evaporation_risk, 1.0)

        return {
            "content": item.content,
            "mass": item.mass,
            "last_used": item.last_used.isoformat(),
            "use_count": item.use_count,
            "correlations": item.correlations,
            "time_unused_days": time_unused.days,
            "evaporation_risk": evaporation_risk,
            "status": (
                "critical"
                if evaporation_risk > 0.8
                else "at_risk" if evaporation_risk > 0.5 else "safe"
            ),
        }
